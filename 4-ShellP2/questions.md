1. Can you think of why we use `fork/execvp` instead of just calling `execvp` directly? What value do you think the `fork` provides?

    > **Answer**: The value fork provides a new child process that will enact the command while the parent (main code) remains intact and continues asking for shell inputs after the forked process is done running. If an error occurs it will be within the child process, based on the result the parent (main code) can choose to print out the error and continue asking the user for input. Fork also allows the main program to continue asking for shell inputs after each command is done running within the fork. If we just used execvp which (replaces the current proocess with a new program, if it suceeds the new program will take over), and chose to do a command like echo "Hello    world", the new process would take over the shell program (main code) would be replaced by ls. Using fork ensure that our parent process (main program) remains active while the child process runs the command seperatley in a duplicate (but seperate branch).

2. What happens if the fork() system call fails? How does your implementation handle this scenario?

    > **Answer**:  When the fork() system call fails it returns -1, this will be the return code that is captured by its parent (main shell code) that ran the command. If fork() fails, no child process is created at all. The failure occurs before a child process exists so the child process never exits.  . My program does perror("fork failed") and returns with an exit code that the command failed. A reason that fork might fail if the system is out of process IDs, memory, or exceeded process limits. When the fork fails in my program, the main code (where fork was executed but failed), takes that pid of < 0 and prints an error message and continues asking for shell inputs. 

3. How does execvp() find the command to execute? What system environment variable plays a role in this process?

    > **Answer**:  The execvp function searches for the given command in a list of directories and replaces the calling process with the new program. The "p" in execvp stands for "path search", meaning it looks through the directories specified in the $PATH environment variable to locate the executable. If the command contains a / (e.g., ./my_program or /usr/bin/python3), execvp treats it as a file path and executes it directly. If no / is found, execvp searches through each directory listed in $PATH and runs the first matching executable it finds. If the command is not found in $PATH, execvp fails and returns -1, typically displaying "command not found".

4. What is the purpose of calling wait() in the parent process after forking? What would happen if we didnâ€™t call it?

    > **Answer**:  wait() is used by the parent process (main code) to pause execution until the child process terminates (which is created by the fork() command).If we ran a fork() command in our main code, but did not run the wait() command, the child process would still run but after it fully terminates it will remain as a zombie in the process table, until the parent collects its exit status. For instance, if a parent program created thousands of child processes without the wait() command, you would run into errors when creating children processes using fork since there would be no more process ID's to assign. Long term and in large scale this would eventually cause errors. Although init (or systemd) may eventually clean up orphaned zombies, it is best practice to explicitly call wait() in the parent process to avoid resource leaks and system instability.

5. In the referenced demo code we used WEXITSTATUS(). What information does this provide, and why is it important?

    > **Answer**:  WEXITSTATUS(status) extracts the code from the terminated child process (usually through wait(&status)). Once the exit code is captured, the main code can have an insight whether the child process that just ran succeeded or failed. If it failed we can output an error, alongside the PID and return code. This is useful in tracking processes and any potential failures, especially if the main program relies on the success of the child process, you can know if any errors occur and why.If the child process failed (i.e., returned a non-zero exit code), the parent can log an error, display the PID and exit code, or take corrective action. For example, a shell might retry a command or print "Command not found" if the exit code is 127. This is useful for process tracking, debugging, and error handling, ensuring that programs relying on child processes can detect and respond to failures effectively.

6. Describe how your implementation of build_cmd_buff() handles quoted arguments. Why is this necessary?

    > **Answer**: My implementation of build_cmd_buff() handles quoted arguments by ensuring that spaces inside quotes are preserved and that the entire quoted section is treated as a single token. This is necessary for commands like echo " hello world !!! " because execvp() expects arguments as an array of strings, and incorrect parsing would lead to misformatted output. In my function, when a double quote (") is detected, I move to the next character and check if it is another double quote. If not, that marks the start of a quoted token. I then initialize token_len and continue iterating while keeping track of the token length. Once I find a closing double quote, I extract the substring from buff_ptr[token_start, token_len], ensuring the quoted content is preserved exactly as entered. This approach prevents consecutive spaces inside quotes from being lost and ensures that commands with quoted arguments (like filenames with spaces) execute correctly. Additionally, the function can be extended to handle single quotes (') and detect unmatched or escaped quotes to improve robustness.

7. What changes did you make to your parsing logic compared to the previous assignment? Were there any unexpected challenges in refactoring your old code?

    > **Answer**:  My original parser split up the command based on spaces so I awas able to reuse that. Some changes I made here were treating double quoted parts of the command differently (making sure to presever the conents of them). Some challenges I faced when refactoring the code were acidentally derefrencing my pointers while extracting the double quote string contentes

8. For this quesiton, you need to do some research on Linux signals. You can use [this google search](https://www.google.com/search?q=Linux+signals+overview+site%3Aman7.org+OR+site%3Alinux.die.net+OR+site%3Atldp.org&oq=Linux+signals+overview+site%3Aman7.org+OR+site%3Alinux.die.net+OR+site%3Atldp.org&gs_lcrp=EgZjaHJvbWUyBggAEEUYOdIBBzc2MGowajeoAgCwAgA&sourceid=chrome&ie=UTF-8) to get started.

- What is the purpose of signals in a Linux system, and how do they differ from other forms of interprocess communication (IPC)?

    > **Answer**:  Signals in a linux system are notifications sent to processes by the OS or other processes. They are used to indicate events like interruptions, terminations, or user defined actions. Some examples of common signals are SIGINT, SIGKILL, SIGCHLD. Signals differ from other IPCs by being more lightweight and instant, they also only send notifications (not complex data). They are also asynchronous, meaning a process can recieve a signal at any time. 

- Find and describe three commonly used signals (e.g., SIGKILL, SIGTERM, SIGINT). What are their typical use cases?

    > **Answer**:  This is used to instantly kill a process (cannnot be Ignored or handled). Its most often used when forcefully killing a process in cases where it is not ending or consuming too many resources. SIGTERM requests a process to terminate gracefully. Gracefully means that it allows the process to clean up resources before it exists, it also stops services or daemons without instant termination. SIGINT interrupts a process from the keyboard, whne presssing CTRL + C. Its typially used when stopping a running command in the terminal such as a script or program.

- What happens when a process receives SIGSTOP? Can it be caught or ignored like SIGINT? Why or why not?

    > **Answer**: SIGSTOP will immediattely pause the process, stopping it from executing until it receives the corresponding SIGCONT signal. This can not be caught, ignored, or blocked, the kernel forcibly stops the process, ensuring that it cannot override or modify the behvaior. 
