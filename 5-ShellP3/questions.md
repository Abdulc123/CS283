1. Your shell forks multiple child processes when executing piped commands. How does your implementation ensure that all child processes complete before the shell continues accepting user input? What would happen if you forgot to call waitpid() on all child processes?

My implementation makes sure that all child processes complete before the shell starts asking the user for more inputs. This is achieved by calling waitpid() on each of the child processes. After all the child processes are forked, the parent processes enter a loop where waitpid() is called on there child processes. Meaning, the parent shell is suspended until all their corresponding child process completes. This makes sure that the commands entered will execute before the shell asks for any more command inputs. If waitpid() was not called, it would spawn multiple zombie child processes since the kernel keeps their exit status until the parent collects it. Also the shell would behave unpredictably since commands could finish at any time and interupt the user. 

2. The dup2() function is used to redirect input and output file descriptors. Explain why it is necessary to close unused pipe ends after calling dup2(). What could go wrong if you leave pipes open?

Its important to close unused pipe ends because it helps avoid a lot of unusual behaviors. For instance, if a process reads from a pipe but the writing end is never closed, it will keep waiting for an infinite amount of time for an input that never arrives. The use of dup2() also prevenets file descriptor exhaustion; each process has a limited number of file descriptors, meaning pipes being left open would waste available descriptors and cause pipe and fork errors down the line. In addtion to this, the kernel also keeps track of open file descriptors so it, meaning if they are not properly closed the pipe does not get deallocated and it causes resource leaks. 


3. Your shell recognizes built-in commands (cd, exit, dragon). Unlike external commands, built-in commands do not require execvp(). Why is cd implemented as a built-in rather than an external command? What challenges would arise if cd were implemented as an external process?

CD is implemented as a built in rather than an external command because changing directories affects the parent shell process itself. Unlike external commands, cd actually modidies the current working directory and switches it. If cd were to be made an external command, the shell would be forking a child process, the child process changes directories, and once the child process is done the parent process would still remain in the original directory.

4. Currently, your shell supports a fixed number of piped commands (CMD_MAX). How would you modify your implementation to allow an arbitrary number of piped commands while still handling memory allocation efficiently? What trade-offs would you need to consider?

To allow x number of piped commands, the best approach would be to dynamically allocate memory instead of using the fixed array. Some tradeoffs would be on performance vs flexibility. Fixed arrays are generally faster but have a limited size. On the other hand, dynamic memory allocation allows for unlimited commands storage but more overhead. malloc and realloc also have the possibility to fail if the system completley runs out of memory, meaning more error checks are required for efficient code. 
